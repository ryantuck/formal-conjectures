# Review: Erdos Problem 1122

**Problem:** Additive functions with few reversals must be c*log(n)
**Source:** [erdosproblems.com/1122](https://www.erdosproblems.com/1122)
**Status:** OPEN

## Source Problem

Let f : N -> R be an additive function (f(ab) = f(a) + f(b) when gcd(a,b) = 1). Define A = {n >= 1 : f(n+1) < f(n)}. If |A intersect [1,X]| = o(X), must f(n) = c*log(n) for some constant c?

Erdos proved the result when A is empty or when f(n+1) - f(n) = o(1). Mangerel made partial progress under stronger density conditions.

## Current Formalization

```lean
@[category research open, AMS 11]
theorem additive_function_monotonicity :
    answer(sorry) ↔
      ∀ (f : ℕ → ℝ),
        (∀ a b, Nat.Coprime a b → f (a * b) = f a + f b) →
        (Filter.Tendsto (fun X : ℕ =>
          (Finset.filter (fun n => f (n + 1) < f n) (Finset.range X)).card / (X : ℝ))
          Filter.atTop (nhds 0)) →
        ∃ c : ℝ, ∀ n > 0, f n = c * Real.log n := by
  sorry
```

## Critical Analysis

### 1. Correct notion of additivity (POSITIVE)

The formalization uses `∀ a b, Nat.Coprime a b → f (a * b) = f a + f b`, which correctly encodes the multiplicatively additive (completely additive on coprime arguments) condition from the source. This is a major improvement over the previous version which used Cauchy additivity.

### 2. Correct codomain (POSITIVE)

`f : ℕ → ℝ` correctly maps natural numbers to reals, matching the source's f : N -> R.

### 3. Correct density-zero condition (POSITIVE)

The density condition is encoded as:
```
Filter.Tendsto (fun X : ℕ =>
  (Finset.filter (fun n => f (n + 1) < f n) (Finset.range X)).card / (X : ℝ))
  Filter.atTop (nhds 0)
```

This says: the proportion of n in {0, ..., X-1} where f(n+1) < f(n) tends to 0 as X -> infinity. This is exactly |A intersect [1,X]| / X -> 0, i.e., A has density zero. This matches the source.

### 4. Correct conclusion (POSITIVE)

`∃ c : ℝ, ∀ n > 0, f n = c * Real.log n` correctly states that f must be a constant multiple of the natural logarithm for all positive n. The restriction to n > 0 is appropriate since log(0) is undefined / problematic.

### 5. Correct answer elaborator usage (POSITIVE)

The `answer(sorry) ↔ ...` pattern is correctly used for this open problem, where the answer is yes or no.

### 6. Division in density computation may involve integer/real coercion subtlety (MINOR)

The expression `(Finset.filter ...).card / (X : ℝ)` divides a natural number (the cardinality, which gets coerced to real) by a real. In Lean 4 / Mathlib, `Finset.card` returns `ℕ`, and dividing `ℕ / ℝ` would require a coercion. The expression likely works because of the automatic coercion from `ℕ` to `ℝ`, but it would be clearer to write `((Finset.filter ...).card : ℝ) / (X : ℝ)`. This is a minor stylistic point and likely not a bug.

### 7. Range starts at 0 vs 1 (MINOR)

`Finset.range X` gives {0, 1, ..., X-1}. The source defines A = {n >= 1 : f(n+1) < f(n)}. Including n = 0 in the filter means we also check whether f(1) < f(0). Since we are taking a density (dividing by X), including one extra element does not affect the limit. This is technically harmless.

### 8. Additive vs completely additive (MINOR)

The source says f is "additive" meaning f(ab) = f(a) + f(b) when gcd(a,b) = 1. This is sometimes called "additive" in number theory, not "completely additive" (which would mean f(ab) = f(a) + f(b) for all a, b). The formalization correctly restricts to coprime arguments, matching the source. However, the conclusion f(n) = c*log(n) for all n > 0 is actually the characterization of completely additive functions (since log is completely additive: log(ab) = log(a) + log(b) for all a, b). For merely additive functions restricted to coprime arguments, the conclusion should still hold since an additive function with this logarithmic form on primes extends uniquely. This is mathematically consistent.

## What a proper formalization would look like

The current formalization is essentially correct. Minor improvements:

```lean
@[category research open, AMS 11]
theorem additive_function_monotonicity :
    answer(sorry) ↔
      ∀ (f : ℕ → ℝ),
        (∀ a b, Nat.Coprime a b → f (a * b) = f a + f b) →
        (Filter.Tendsto (fun X : ℕ =>
          ((Finset.filter (fun n => f (n + 1) < f n) (Finset.range X)).card : ℝ) / (X : ℝ))
          Filter.atTop (nhds 0)) →
        ∃ c : ℝ, ∀ n > 0, f n = c * Real.log n := by
  sorry
```

The only change is making the coercion of `.card` to `ℝ` explicit.

## Confidence: **88%**

The formalization correctly captures all essential aspects of the source problem: the multiplicative additivity on coprime arguments, the density-zero condition on the set of "decreases," and the conclusion that f must be c*log(n). The quantifier structure is correct, the answer elaborator is properly used, and no mathematical content is missing. The only minor concerns are the coercion in the division and the inclusion of n = 0 in the range, neither of which affects correctness.
