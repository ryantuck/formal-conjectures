# Review: Erdos Problem 1153

**Problem:** Lagrange basis functions and subintervals
**Source:** [erdosproblems.com/1153](https://www.erdosproblems.com/1153)
**Status:** OPEN

## Source Problem

For points x_1,...,x_n ∈ [-1,1], define Lagrange basis polynomials l_k(x) = ∏_{i≠k}(x-x_i)/∏_{i≠k}(x_k-x_i), and let λ(x) = Σ_k |l_k(x)|.

**Conjecture**: For any fixed -1 ≤ a < b ≤ 1, is it true that

  max_{x ∈ [a,b]} λ(x) > (2/π - o(1)) log n?

Known: Bernstein (1931) proved this for [a,b] = [-1,1]. Erdos (1961) improved to max_{[-1,1]} λ(x) > (2/π) log n - O(1), which is tight by Chebyshev nodes.

## Current Formalization

```lean
noncomputable def lagrangeBasis {n : ℕ} (nodes : Fin n → ℝ) (k : Fin n) (x : ℝ) : ℝ := sorry

noncomputable def Λ {n : ℕ} (nodes : Fin n → ℝ) (x : ℝ) : ℝ :=
  ∑ k : Fin n, |lagrangeBasis nodes k x|

theorem lagrange_basis_subintervals :
    answer(sorry) ↔ ∀ (a b : ℝ), -1 ≤ a → a < b → b ≤ 1 →
      ∀ᶠ n : ℕ in atTop, ∃ (nodes : Fin n → ℝ),
        (∀ i, nodes i ∈ Set.Icc (-1 : ℝ) 1) ∧
        (∀ i j, i ≠ j → nodes i ≠ nodes j) ∧
        (⨆ x ∈ Set.Icc a b, Λ nodes x) > (2 / Real.pi - sorry) * Real.log n := by
  sorry
```

## Critical Analysis

### 1. Quantifier over nodes is WRONG (CRITICAL)

The source conjecture asks: for **ANY** choice of n nodes in [-1,1], is max_{[a,b]} λ(x) > (2/π - o(1)) log n?

The formalization uses **∃ (nodes : Fin n → ℝ)** — an existential. This asks whether there **exist** nodes achieving the bound, not whether **all** nodes satisfy it.

This fundamentally reverses the problem:
- **Source**: ∀ nodes, the bound holds (a lower bound on ALL node sets)
- **Formalization**: ∃ nodes achieving the bound (existence of a single good node set)

The existential version is trivially true (Chebyshev nodes achieve it on [-1,1], so suitable nodes exist).

### 2. The o(1) term uses sorry (MODERATE)

`(2 / Real.pi - sorry)` embeds a sorry inside the formula. The o(1) correction should be expressed as: for all ε > 0, eventually the bound (2/π - ε) log n holds. The proper formulation:

```lean
∀ ε > 0, ∀ᶠ n in atTop, ∀ nodes, ... →
  sup_{x ∈ [a,b]} Λ nodes x > (2/π - ε) * log n
```

### 3. lagrangeBasis is sorry (MODERATE)

The definition is a placeholder. The correct formula is:

  l_k(x) = ∏_{i ≠ k} (x - x_i) / ∏_{i ≠ k} (x_k - x_i)

This could be implemented in Lean, but is left as sorry.

### 4. Λ definition is good

`∑ k : Fin n, |lagrangeBasis nodes k x|` correctly defines λ(x) as the Lebesgue function.

### 5. Supremum may not be well-behaved

`⨆ x ∈ Set.Icc a b, Λ nodes x` uses the lattice supremum over ℝ, which works since ℝ is conditionally complete. However, for a continuous function on a compact set, this equals the maximum, so it's fine.

## What a proper formalization would look like

```lean
theorem lagrange_basis_subintervals :
    answer(sorry) ↔ ∀ (a b : ℝ), -1 ≤ a → a < b → b ≤ 1 →
      ∀ (ε : ℝ), ε > 0 →
      ∀ᶠ n : ℕ in atTop, ∀ (nodes : Fin n → ℝ),
        (∀ i, nodes i ∈ Set.Icc (-1 : ℝ) 1) →
        (∀ i j, i ≠ j → nodes i ≠ nodes j) →
        (⨆ x ∈ Set.Icc a b, Λ nodes x) > (2 / Real.pi - ε) * Real.log n := by
  sorry
```

## Confidence: **8%**

The Lebesgue function Λ is correctly defined (modulo sorry lagrangeBasis), but the critical ∃/∀ quantifier error over nodes completely changes the problem's meaning. The embedded sorry in the formula is also problematic.
