# Review: Erdos Problem 1101

**Problem:** Good sequences and gaps in sifted sets
**Source:** [erdosproblems.com/1101](https://www.erdosproblems.com/1101)
**Status:** OPEN

## Source Problem

Let u = {u_1 < u_2 < ...} be a sequence of pairwise coprime integers with convergent reciprocal sum. Define {a_1 < a_2 < ...} as the integers not divisible by any u_i. For t_x satisfying u_1 ... u_{t_x} <= x < u_1 ... u_{t_x} u_{t_x+1}, the sequence is "good" if for all epsilon > 0 and sufficiently large x:

  max_{a_k < x} (a_{k+1} - a_k) < (1+epsilon) * t_x * prod_i (1 - 1/u_i)^{-1}

Two questions:
1. Erdos conjectured: No good sequence exists with u_n < n^{O(1)} (polynomial growth).
2. Erdos conjectured: A good sequence exists with u_n <= e^{o(n)} (sub-exponential growth).

## Current Formalization

```lean
def ASet (u : ℕ → ℕ) : Set ℕ :=
  { a | ∀ i, ¬ u i ∣ a }

noncomputable def A (u : ℕ → ℕ) (n : ℕ) : ℕ :=
  Nat.nth (fun a => a ∈ ASet u) n

noncomputable def t (u : ℕ → ℕ) (x : ℕ) : ℕ :=
  sSup { k | ∏ i ∈ Finset.range k, u i ≤ x }

def IsGood (u : ℕ → ℕ) : Prop :=
  StrictMono u ∧
  (∀ i j, i ≠ j → Coprime (u i) (u j)) ∧
  Summable (fun n => 1 / (u n : ℝ)) ∧
  ∀ ε > 0, ∀ᶠ x in atTop,
    ∀ k, A u k < x →
      (A u (k + 1) : ℝ) - A u k < (1 + ε) * (t u x : ℝ) * (∏' i : ℕ, (1 - 1 / (u i : ℝ)))⁻¹

theorem erdos_1101.polynomial :
    ¬ ∃ u, IsGood u ∧ ∃ k : ℕ, (fun n => (u n : ℝ)) =O[atTop] (fun n => (n : ℝ) ^ k) := by
  sorry

theorem erdos_1101.subexponential :
    ∃ u, IsGood u ∧ (fun n => Real.log (u n : ℝ)) =o[atTop] (fun n => (n : ℝ)) := by
  sorry
```

## Critical Analysis

### 1. IsGood definition captures the gap bound correctly (OK)

The gap bound `(A u (k + 1) : R) - A u k < (1 + epsilon) * t_x * (prod (1 - 1/u_i))^{-1}` matches the source problem's definition of a "good" sequence. The use of `∀ ε > 0, ∀ᶠ x in atTop` correctly captures "for all epsilon > 0 and sufficiently large x."

### 2. t_x definition uses sSup which may be problematic (MODERATE)

The definition `t u x = sSup { k | prod_{i < k} u i <= x }` is mathematically correct in intent, but `sSup` over a potentially unbounded set of natural numbers will return 0 if the set is empty and may behave unexpectedly. For a well-defined sequence with u_i >= 2 and products growing, the set will be bounded, so this should be fine in practice. However, there is no explicit guard for this.

### 3. Gap bound quantifies over all k with A_k < x (MINOR)

The source says "max_{a_k < x} (a_{k+1} - a_k)" which is the maximum gap among elements below x. The formalization uses "for all k with A(k) < x, the gap is bounded." This is equivalent to bounding the maximum gap, since if all individual gaps are bounded by B, then the max is bounded by B. This is correct.

### 4. Infinite product vs tprod (MODERATE)

The formalization uses `(∏' i : ℕ, (1 - 1 / (u i : ℝ)))⁻¹`. The source uses `prod_i (1 - 1/u_i)^{-1}`. This is the same mathematically, but for the tprod to converge, we need the reciprocal sum to converge, which is explicitly assumed. However, there is a subtlety: if any u_i = 1, the factor (1 - 1/u_i) = 0 and the product is 0, making the inverse undefined/infinite. The pairwise coprimality and the fact that these are a strictly monotone sequence of positive integers should exclude u_i = 1, but this is not explicitly guarded. When u_0 = 1, the ASet would be empty.

### 5. Polynomial growth conjecture formalization (OK)

The statement `¬ ∃ u, IsGood u ∧ ∃ k, u =O[atTop] n^k` correctly captures "no good sequence with polynomial growth." The use of Big-O notation for u_n = O(n^k) for some fixed k is the right way to express polynomial growth.

### 6. Sub-exponential growth conjecture formalization (OK)

The statement `∃ u, IsGood u ∧ log(u n) =o[atTop] n` correctly captures "there exists a good sequence with u_n <= e^{o(n)}". Since u_n <= e^{o(n)} is equivalent to log(u_n) = o(n).

### 7. Missing answer elaborator (MINOR)

Both theorems directly assert the conjectures rather than using the `answer(sorry) ↔ ...` pattern. Since these are open problems where Erdos conjectured specific answers, directly asserting the conjectured answer is a reasonable choice, though it deviates from the convention used elsewhere for open problems.

### 8. ASet should exclude 0 (MINOR)

The `ASet` includes 0 (since no u_i divides 0... actually, in Lean/Mathlib, every natural number divides 0, so 0 would NOT be in ASet). Also `Nat.nth` for an infinite set should work correctly. However, the source sequence {a_1 < a_2 < ...} starts from positive integers. The formalization's use of `Nat.nth` with 0-indexing may cause an off-by-one issue.

## What a proper formalization would look like

The current formalization is quite good. Minor improvements:

```lean
/-- Ensure u starts at >= 2 to avoid degenerate cases -/
def IsGood (u : ℕ → ℕ) : Prop :=
  StrictMono u ∧
  (∀ i, 2 ≤ u i) ∧
  (∀ i j, i ≠ j → Coprime (u i) (u j)) ∧
  Summable (fun n => 1 / (u n : ℝ)) ∧
  ∀ ε > 0, ∀ᶠ x in atTop,
    ∀ k, A u k < x →
      (A u (k + 1) : ℝ) - A u k < (1 + ε) * (t u x : ℝ) * (∏' i : ℕ, (1 - 1 / (u i : ℝ)))⁻¹
```

## Confidence: **78%**

This is a strong formalization. The key definitions (ASet, A, t, IsGood) capture the source problem well. The two conjectures are correctly stated with appropriate asymptotic notation. The main concerns are minor: potential edge cases with small values of u, the tprod convergence assumption, and the missing answer elaborator. The mathematical content is faithfully represented.
