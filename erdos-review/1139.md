# Review: Erdos Problem 1139

**Problem:** Gaps between integers with at most 2 prime factors
**Source:** [erdosproblems.com/1139](https://www.erdosproblems.com/1139)
**Status:** OPEN

## Source Problem

Let 1 <= u_1 < u_2 < ... denote the sequence of integers having at most 2 prime factors. Is it true that:

  limsup_{k -> infinity} (u_{k+1} - u_k) / log k = infinity?

## Current Formalization

```lean
@[category research open, AMS 11]
theorem erdos_1139 :
    answer(sorry) ↔
      letI u := Nat.nth (fun n ↦ 0 < n ∧ Ω n ≤ 2)
      atTop.limsup (fun k : ℕ ↦ (((u (k + 1) : ℝ) - (u k : ℝ)) / Real.log (↑k + 1) : EReal)) = ⊤ := by
  sorry
```

## Critical Analysis

### 1. Correct use of Nat.nth for enumeration (MINOR positive)

`Nat.nth (fun n => 0 < n ∧ Ω n ≤ 2)` correctly enumerates the positive integers with at most 2 prime factors (counted with multiplicity by Omega). This gives the sequence u_1, u_2, ... (with 0-indexed: u(0), u(1), ...).

### 2. Correct limsup = infinity encoding (MINOR positive)

The use of `atTop.limsup ... = ⊤` in `EReal` correctly encodes limsup = infinity. The `EReal` type allows the value infinity (⊤).

### 3. Index shift: log(k+1) vs log(k) (MINOR)

The source uses log k, while the formalization uses `Real.log (k + 1)`. This is a standard 0-indexing adjustment: when k starts from 0, using k+1 avoids log(0) = -infinity. For k >= 1, log(k+1) and log(k) are asymptotically equivalent, so this does not affect the limsup being infinity.

### 4. Omega vs omega (MODERATE)

The formalization uses `Ω n` (big Omega, counting prime factors **with** multiplicity). The source says "at most 2 prime factors" which could mean either omega(n) <= 2 (distinct prime factors) or Omega(n) <= 2 (prime factors with multiplicity). The standard interpretation in analytic number theory for "integers with at most k prime factors" typically means Omega(n) <= k (with multiplicity), making the formalization's choice of big Omega reasonable. However, there is some ambiguity.

### 5. Correct answer elaborator usage (MINOR positive)

The use of `answer(sorry)` is appropriate for an open yes/no problem.

### 6. Correct gap computation (MINOR positive)

`u(k+1) - u(k)` with real-valued subtraction (via casting to ℝ) correctly computes the gap between consecutive terms.

### 7. Positivity constraint (MINOR)

The predicate includes `0 < n`, which ensures only positive integers are counted. Since u_1 >= 1 in the source, this correctly excludes 0.

## What a proper formalization would look like

The current formalization is essentially correct. A minor variant with explicit omega vs Omega clarification:

```lean
-- Current formalization is good. If distinct primes were intended:
-- Nat.nth (fun n ↦ 0 < n ∧ ω n ≤ 2)
-- But Ω is the standard interpretation.
theorem erdos_1139 :
    answer(sorry) ↔
      letI u := Nat.nth (fun n ↦ 0 < n ∧ Ω n ≤ 2)
      atTop.limsup (fun k : ℕ ↦ (((u (k + 1) : ℝ) - (u k : ℝ)) / Real.log (↑k + 1) : EReal)) = ⊤ := by
  sorry
```

## Confidence: **85%**

The formalization accurately captures the source problem. The sequence of integers with at most 2 prime factors is correctly enumerated, the gap is properly computed, and the limsup = infinity condition is faithfully encoded using EReal. The only potential issues are: (1) the Omega vs omega ambiguity (reasonable choice made), and (2) the minor index shift from log(k) to log(k+1) which does not affect the mathematical content.
