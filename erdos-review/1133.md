# Review: Erdos Problem 1133

**Problem:** Existence of polynomials with large bounds given interpolation constraints
**Source:** [erdosproblems.com/1133](https://www.erdosproblems.com/1133)
**Status:** OPEN

## Source Problem

For any constant C > 0, there exists epsilon > 0 such that for sufficiently large n: given any points x_1, ..., x_n in [-1,1], one can find y_1, ..., y_n in [-1,1] such that any polynomial P of degree m < (1+epsilon)n satisfying P(x_i) = y_i for at least (1-epsilon)n indices must have max_{x in [-1,1]} |P(x)| > C.

## Current Formalization

```lean
@[category research open, AMS 41]
theorem polynomial_large_bounds (C : ℝ) (hC : 0 < C) :
    ∃ (ε : ℝ), 0 < ε ∧
      ∀ᶠ n in atTop, ∀ (x : Fin n → ℝ),
        (∀ i, x i ∈ Set.Icc (-1 : ℝ) 1) →
        ∃ (y : Fin n → ℝ), (∀ i, y i ∈ Set.Icc (-1 : ℝ) 1) ∧
          ∀ (P : Polynomial ℝ), P.natDegree < ⌈(1 + ε) * n⌉₊ →
            (↑{i : Fin n | P.eval (x i) = y i}.toFinset.card : ℝ) ≥ (1 - ε) * n →
            ⨆ t ∈ Set.Icc (-1 : ℝ) 1, |P.eval t| > C := by
  sorry
```

## Critical Analysis

### 1. Quantifier structure is correct (POSITIVE)

The rewrite correctly captures the nested quantifier structure:
- For all C > 0 (theorem parameter)
- There exists epsilon > 0
- For all sufficiently large n
- For all x_1, ..., x_n in [-1,1]
- There exist y_1, ..., y_n in [-1,1]
- For all polynomials P of degree < (1+epsilon)n
- If P interpolates at >= (1-epsilon)n points, then max|P| > C

This exactly matches the source problem's quantifier nesting.

### 2. Degree bound is correctly formalized (POSITIVE)

The source requires degree m < (1+epsilon)n. The formalization uses `P.natDegree < ⌈(1 + ε) * n⌉₊`, which is the natural number ceiling of (1+epsilon)*n. Since natDegree is a natural number and (1+epsilon)*n is real, using the ceiling is the correct way to discretize this bound. The strict inequality `<` with ceiling means `natDegree <= floor((1+epsilon)*n)` for non-integer values, which faithfully captures "degree less than (1+epsilon)n".

### 3. Interpolation condition is correctly formalized (POSITIVE)

The source says "P(x_i) = y_i for at least (1-epsilon)n indices". The formalization uses:
```
(↑{i : Fin n | P.eval (x i) = y i}.toFinset.card : ℝ) ≥ (1 - ε) * n
```
This counts the number of indices i where P(x_i) = y_i and requires this count to be at least (1-epsilon)*n. This is a faithful translation.

### 4. Sup norm on [-1,1] (MODERATE concern)

The conclusion uses `⨆ t ∈ Set.Icc (-1 : ℝ) 1, |P.eval t| > C`. The `iSup` (⨆) over a set in Lean computes the supremum in the lattice of `ℝ` with the `ConditionallyCompleteLattice` structure. For this to work correctly:

- The set `Set.Icc (-1 : ℝ) 1` is nonempty (it contains 0).
- The function `fun t => |P.eval t|` is continuous on a compact set, so it attains its supremum.
- However, `⨆ t ∈ S, f t` in Lean's lattice framework computes as `iSup (fun t => iSup (fun _ : t ∈ S => f t))`. For real numbers, this equals `sSup (f '' S)` when `S` is nonempty and `f` is bounded above on `S`, which holds here since polynomials are continuous and [-1,1] is compact.

This should be mathematically correct, though one could alternatively use `sSup (Set.image (fun t => |P.eval t|) (Set.Icc (-1) 1))` for clarity.

### 5. Exact equality in interpolation condition (MINOR)

The formalization requires `P.eval (x i) = y i` as exact equality. In the source problem, "P(x_i) = y_i" also means exact equality. This is correct. (One might worry about whether approximate interpolation was intended, but the source explicitly states equality.)

### 6. No answer elaborator needed (POSITIVE)

Since this is an open problem stated as a conjecture (not a yes/no question), the formalization correctly does not use `answer(sorry)`. The statement directly asserts the conjectured property. This matches the source, which states the conjecture as a positive claim rather than asking "is it true that...?"

### 7. Use of ∀ᶠ n in atTop (POSITIVE)

The "for sufficiently large n" is correctly encoded as `∀ᶠ n in atTop`. Since `open Filter` is present, `atTop` refers to the filter of cofinite sets on natural numbers, which is exactly the "eventually" quantifier for "for all sufficiently large n".

### 8. Fin n for indexing (MINOR)

Using `Fin n` to index the n points is a clean Lean idiom. It correctly gives exactly n points x_1, ..., x_n and n values y_1, ..., y_n.

## What a proper formalization would look like

The current formalization is already a faithful and complete capture of the source problem. No structural changes are needed. The formalization is essentially correct as written.

```lean
-- The current formalization is already correct. Reproduced for completeness:
@[category research open, AMS 41]
theorem polynomial_large_bounds (C : ℝ) (hC : 0 < C) :
    ∃ (ε : ℝ), 0 < ε ∧
      ∀ᶠ n in atTop, ∀ (x : Fin n → ℝ),
        (∀ i, x i ∈ Set.Icc (-1 : ℝ) 1) →
        ∃ (y : Fin n → ℝ), (∀ i, y i ∈ Set.Icc (-1 : ℝ) 1) ∧
          ∀ (P : Polynomial ℝ), P.natDegree < ⌈(1 + ε) * n⌉₊ →
            (↑{i : Fin n | P.eval (x i) = y i}.toFinset.card : ℝ) ≥ (1 - ε) * n →
            ⨆ t ∈ Set.Icc (-1 : ℝ) 1, |P.eval t| > C := by
  sorry
```

## Confidence: **88%**

The formalization faithfully captures all aspects of the source problem: the quantifier structure, the degree bound, the interpolation condition, and the sup-norm conclusion. The main source of residual uncertainty is whether `⨆ t ∈ Set.Icc (-1 : ℝ) 1, |P.eval t| > C` behaves exactly as the mathematical supremum in Lean's type theory (it should, given that the set is nonempty and the function is bounded above, but this depends on the lattice instance for ℝ). A secondary minor concern is whether `{i : Fin n | P.eval (x i) = y i}.toFinset` requires decidability instances that may need to be provided, but with `open Classical` or `noncomputable` this should be fine in the `sorry`-based framework.
